# 第四章 表达式

## 表达式基础
- 结合律：组合运算对象的方向，*如：20-15-3的结果是2而不是8*   
- **重载运算符**：当运算符作用在类类型的运算对象时，用户可以自行定义其含义，但**运算对象的个数、优先级和结婚率无法改变**
- **左值和右值**：
    - 右值：储存在寄存器或立即数，用的是对象的**值**（内容）
    - 左值：储存在内存，用的是对象的**身份**（内存中的地址）
- 对于没有指定执行顺序的运算符，如果表达式指向并修改了**同一个对象**，将会引发错误产生未定义的行为  
```cpp
int i = 0;
cout << i <<< i++ <<endl;           //编译器不知道先输出i还是i++，表达式的结果是未知的
```

## 算术运算符

- 运算对象和结果都是**右值**  
- 取模`%`:`m % n`符号与`m`相同
  - `m % n` `m % (-n)`等价于`m % n`
  - `(-m) % n` `(-m) % (-n)`等价于`-(m % n)`  
- 溢出：当计算的结果超出该类型所能表示的范围时就会产生溢出
  
 ## 逻辑和关系运算符
 
 - 返回布尔类型，运算对象和结果都是**右值**    
 - 短路求值：  
   - `&&`:当且仅当**左侧运算对象为真**时，才对右侧运算对象求值  
   - `||`:当且仅当**左侧运算对象为假**时，才对右侧运算对象求值
  
## 赋值运算符

- 如果赋值运算的左右侧运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型
- 赋值运算符满足右结合律，*如 `ival = jval = 0;`等价于`ival = (jval = 0);`*   

## 递增和递减运算符  
**前置**：先将运算对象加(减)，返回改变后的对象 **（左值）**   
**后置**：将运算对象加(减)，返回求值前运算对象的副本  **（右值）**
```cpp
int i = 0, j;
j = ++i;              //前置：j = 1, i = 1            
int v = 0, u;
u = v++;              //后置：u = 0, v = 1
```
- 最好使用前置版
- 后置版优先级高于解引用，`*p++`等价于`*(p++)`  
- 一条语句中既改变了某个对象的值，又使用该值，运算顺序未知
```cpp
*beg = toupper(*beg++);         //编译器如何运算未知
```

## 成员访问运算符
- `ptr->mem`等价于`(*ptr).mem`
  - 解引用优先级低于点运算符
- 箭头运算符：结果是**左值**
- 点运算符：结果与成员所属对象是左右值**相同**

## 条件运算符
`cond ? expr1 : expr2`：先求`cond`的值，条件为真对`expr1`求值并返回该值，条件为假相反   
- 优先级非常低，通常加括号，**右结合律**
- 当`expr1``expr2`都是左值且能转换为同一种左值类型，结果是**左值**；否则结果是**右值**  
- 允许在`expr`中嵌套另一个条件运算符

## 位运算符
- 移位运算符`<<``>>`**左结合律**

## sizeof运算符
- 返回一条表达式或一个类型名字所占的**字节数**。返回的类型是 `size_t`的**常量表达式**，**右结合律**
- 两种形式： `sizeof (type)`和 `sizeof expr`
- 并不会实际计算其运算对象的值，对于`sizeof *p`即使`p`是一个无效指针也是安全的
- 对数组运算得到整个数组所占空间大小
```cpp
int A[3];
cout << sizeof(A)/sizeof(*A);       //输出3，为数组大小
```
## 逗号运算符
- 含有两个运算对象，先对左侧表达式求值，然后将结果丢掉，再对右侧表达式求值并返回该结果

## 类型转换
### 隐式类型转换
- 比 `int`类型小的整数值先提升为较大的整数类型
- 条件中，非布尔为`0`或`nullptr`转换`false`，否则转换成`true`
- 初始化中，初始值转换成变量的类型
- 算术运算或者关系运算的运算对象有多种类型，要转换成同一种类型
- 函数调用时
#### 算术转换
- 整型提升：比`int`小的转换为`int`，比`int`大的转换为`unsigned int``long``unsigned long``long long``unsigned long long`中能装下最小的类型
#### 其他类型隐式转换
- 数组转换成指针：除以下情况，数组自动转换为指向数组首元素的指针
  - 作为`decltype`的参数
  - 作为`&``sizeof``typeid`的运算对象
  - 用引用初始化数组
- 允许指向常量的指针和引用转换为指向非常量
### 显式类型转换
`cast-name<type>(expression)`：转换为指针要将`*`写在`<>`里面
- 算术类型转算术类型，指针类型转指针类型等
  - **static_cast**：任何明确定义的类型转换，只要不包含底层const，都可以使用，   *如： `int i; double slope = static_cast<double>(i);`*
  - **const_cast**：只能改变运算对象的底层const，一般可用于去除const性质，   *如： `const char *pc; char *p = const_cast<char*>(pc)`*
- **reinterpret_cast**：任意类型转换，   *如：算术转指针`int *ip; char *pc = reinterpret_cast<char*>ip`*
- 旧式强制类型转换：`type (expr)``(type) exper`根据类型行为与上述三种类似（**不推荐**）
