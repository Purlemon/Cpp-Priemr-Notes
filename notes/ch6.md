# 第六章 函数

## 函数基础

- **函数定义**：包括返回类型、函数名字和0个或者多个**形参**（parameter）组成的列表和函数体
- **调用运算符**：调用运算符的形式是一对圆括号 `()`，作用于一个表达式，该表达式是函数或者指向函数的指针
- 圆括号内是用逗号隔开的**实参**（argument）列表
- 函数调用过程：
  - 1.主调函数（calling function）的执行被中断
  - 2.被调函数（called function）开始执行
- **形参和实参**：
  - 形参和实参的**个数**和**类型**必须匹配上
  - 形参一定会被初始化  
- **返回类型**： `void`表示函数不返回任何值。函数的返回类型**不能是数组类型或者函数类型**，但可以是指向数组或者函数的指针

### 局部对象

- **生命周期**：对象的生命周期是程序执行过程中该对象存在的一段时间
- **局部变量**（local variable）：形参和函数体内部定义的变量统称为局部变量。它对函数而言是局部的，对函数外部而言是**隐藏**的
- **自动对象**：只存在于块执行期间的对象。当块的执行结束后会被销毁，它的值就变成**未定义**的了
- **局部静态对象**： 
  - `static`类型的局部变量，生命周期贯穿函数调用前后
  - 没有显式初始化则执行**值初始化**（内置类型初始化为0）
### 函数声明

- **函数声明**：
  - 无需函数体，用一个分号替代
  - 形参可以没有名字只有类型名称
- **在头文件中进行函数声明**：建议变量在头文件中声明；在源文件中定义

## 参数传递

- 形参初始化的机理和变量初始化一样。
- **引用传递**（passed by reference）：又称传引用调用（called by reference），指**形参是引用类型**，引用形参是它对应的实参的别名
- **值传递**（passed by value）：又称传值调用（called by value），指实参的值是通过**拷贝**传递给形参。
### 传值参数

- 当初始化一个非引用类型的变量时，初始值被拷贝给变量
- 函数对形参做的所有操作都不会影响实参
- **指针形参**：效果等价于引用形参
### 传引用参数

- 通过使用引用形参，允许函数改变一个或多个实参的值
- 引用形参直接关联到绑定的对象，而非对象的副本
- 使用引用形参可以用于**返回额外的信息**
- 经常用引用形参来避免不必要的复制
- 如果无需改变引用形参的值，最好将其声明为**常量引用**

### const形参和实参

- 形参的顶层`const`被忽略。`void func(const int i);`调用时既可以传入`const int`也可以传入`int`
 ```cpp
 void fcn(const int i);
 void fdn(int i);               //错误：不能重载，可以传入相同类型的参数
 ```
- 形参使用常量引用可以**传递字面值或表达式**作为参数，但引用不行

### 数组形参
实际上传递的是指向数组首元素的指针
```cpp
//三种等价
void print(int* arr);
void print(int arr[]);
void print(int arr[10]);        //本质是传指针，所以10这个维度会自动被编译器忽视
```
- 管理指针（数组）形参
  - 1.数组本身包含结束标记，*如：C风格字符串*
  - 2.传递数组首元素和尾后元素指针`void print(begin(arr), end(arr))`
  - 3.显式传递数组大小`void print(int arr[], size_t size)`
- 数组引用形参
```cpp
//形参是数组的引用，所以维度是类型的一部分
void print(int (&arr)[10])
{
    for (auto i : arr)
        cout << i;
}
//限制了函数的可用性，只能传递大小为10的数组
int j[2] = {0, 1};
print(j);             //错误：数组大小只能为10
```
- 传递多维数组
实际上是传递指向数组的指针，所以数组第二维（以及后面所有维度）的大小都不能省略
```cpp
//三种等价
void print(int (*matrix)[10], int row_size);
void print(int matrix[][10], int row_size);
void print(int matrix[5][10], int row_size);      //编译器会忽略5这个第一维度
```
### 含有可变形参的函数
所有实参类型相同，数量不定，模板类型`initializer_list`

| 操作 | 解释 |
|-----|-----|
| `initializer_list<T> lst;` | 默认初始化；`T`类型元素的空列表 |
| `initializer_list<T> lst{a,b,c...};` | `lst`的元素数量和初始值一样多；`lst`的元素是对应初始值的副本；列表中的元素是`const`。 |
| `lst2(lst)` | 拷贝或赋值一个`initializer_list`对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素。 |
| `lst2 = lst` | 同上 |
| `lst.size()` | 列表中的元素数量 |
| `lst.begin()` | 返回指向`lst`中首元素的指针 |
| `lst.end()` | 返回指向`lst`中微元素下一位置的指针 |
- `initializer_list`对象是常量
- 向`initializer_list`形参传递值的序列，用花括号

```cpp
void err_msg(initializer_list<string> il)          //形参是string序列       
{
    for (auto beg = il.begin(); beg != il.end(); ++ beg)
        cout << *beg << " ";
}
string x = "jkl";
err_msg({"abc", "efg", x});                         //用{}传入实参序列
```
## 返回类型和return语句

### 无返回值函数

- 没有返回值的 `return`语句只能用在返回类型是 `void`的函数中
- 返回 `void`的函数不要求非得有 `return`语句
- 可以在`void`函数中间位置用`return`提前退出

### 有返回值函数

- `return`语句的返回值的类型必须和函数的返回类型相同，或者能够**隐式地**转换成函数的返回类型
- 值的返回：返回的值用于初始化调用点的一个**临时量**，该临时量就是函数调用的结果
- **不要返回局部对象的引用或指针**：函数调用后内部空间被销毁
- 调用一个**返回引用**的函数得到**左值**，其他返回类型得到右值
- **列表初始化返回值**：函数可以返回花括号包围的值的列表
  - 返回内置类型，花括号只能包含一个值，且该值空间不应该大于目标类型空间
  - 返回类类型，由类本身定义初始值如何使用
```cpp
string x = "jkl";
vector<string> process()
{
    return {"abc", "efg", x};
}
```
- 主函数main的返回值：如果结尾没有`return`，编译器将隐式地插入一条返回0的`return`语句。返回0代表执行成功

### 返回数组指针或引用
无法返回数组，用返回数组指针或引用代替
```cpp
int arr[10];
int *p1[10];            //p1是一个数组，含有10个int类型指针
int (*p2)[10] = &arr;   //p2是一个指针，指向含有10个int类型的数组arr
int (&r)[10] = arr;     //r是一个引用，与含有10个int类型的数组arr绑定
int (*func1())[10];     //func1返回一个指针，指向含有10个int类型数组
int (&func2())[10];     //func2返回一个含有10个int类型的数组的引用
```
- 使用尾置返回类型
在形参列表后以`->`开头表示返回类型，在原来的位置放置`auto`
```cpp
auto func3() -> int(*)[10];           //func3()返回一个一维数组指针，含有10个int类型
//不要返回指向二维数组的指针，数据会乱，不知道为什么
auto func4() -> int(&)[10];           //func4()返回一个一维数组引用，含有10个int类型
auto func5() -> int(&)[5][10];        //func5()返回一个二维数组引用，含有5行10列int类型
```
- 使用decltype
注：`decltype`对数组的结果是数组
```cpp
int odd[5] = {1, 3, 5, 7, 9};
decltype(odd) *func6()
{
    return &odd;        //返回一个指针，指向含有5个int类型的数组
}
```
## 函数重载
- **重载**：同一作用域内几个函数名字相同但形参列表不同
  - 不允许两个函数除了返回类型以外全部相同
- `main`函数不能重载
- **重载和const形参**：
  - 一个有顶层const的形参和没有它的函数无法区分，*如：`int lookup(int* const)`和 `int lookup(int*)`无法区分*
  - 相反，是否有某个底层const形参可以区分，*如`int lookup(int*)`和 `int lookup(const int*)`可以区分*
- **重载和作用域**：若在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体，在不同的作用域中无法重载函数名

## 特殊用途语言特性

### 默认实参

- `string screen(int ht = 24, int wid = 80, char backgrnd = ' ');`
- 一旦某个形参被赋予了默认值，那么它之后的形参都必须要有默认值
- 函数可以被多次声明，但默认实参只能被声明一次
- 局部变量不能作为默认实参
- 调用默认实参，只需在调用函数时省略该实参
  - 从第一个默认实参开始调用
```cpp
screen(66);                     //等价于screen(66, 80, ' ');
screen(66, 256);                //等价于screen(66, 256, ' ');
screen(66, 256, '#');           //等价于screen(66, 256, '#');
```

### 内联函数

- 普通函数的缺点：调用函数比求解等价表达式要慢得多
- `inline`函数可以避免函数调用的开销，可以让编译器在编译时**内联地展开**该函数
  - 很多编译器不支持内联递归
- `inline`函数应该在头文件中定义

### constexpr函数

- 指能用于常量表达式的函数，*如：`constexpr int new_sz() {return 42;}`*
  - 函数的返回类型及所有形参类型都要是字面值类型
  - 函数中必须且只能有一条`return`语句
- `constexpr`函数应该在头文件中定义

### 调试帮助
 `assert`预处理宏，头文件`<cassert>`：用于检查不能发生的条件
- `assert(expr)`: `expr`为**假**：终止程序
- 开关调试状态：`#define NDEBUG`可以使`assert`失效
- 可以用`NDEBUG`编写自己的调试代码，若`NDEBUG`未定义，则执行`#ifndef NDEBUG` `#endif``之间的代码
```cpp
void print(){
    #ifndef NDEBUG
        cerr << __func__ << "..." << endl;
    #endif
}
```
**调试相关变量**  
| 变量名 | 含义 | 
|---|---|
| `__func__` | 当前函数名字的字符串字面值  |
| `__LINE__`| 当前行号的整型字面值 | 
| `__FILE__` | 文件名的字符串字面值 | 
| `__TIME__` | 文件编译时间的字符串字面值  |
| `__DATE__` | 文件编译日期的字符串字面值 | 

## 函数匹配

- 重载函数匹配的**三个步骤**：1.候选函数；2.可行函数；3.寻找最佳匹配
  - **候选函数**：选定本次调用对应的重载函数集，集合中的函数称为候选函数
    - 与被调用函数同名
    - 声明在调用点可见
  - **可行函数**：考察本次调用提供的实参，选出可以被这组实参调用的函数，新选出的函数称为可行函数
    - 形参数量与本次调用提供实参数量相同
    - 每个实参的类型与对应形参类型相同，或能转换为形参类型
  - **寻找最佳匹配**：基本思想：实参类型和形参类型越接近，它们匹配地越好
- 如果重载函数的区别是引用或指针形参含有`const`，编译器将根据实参是否是常量选择

## 函数指针

- **函数指针**：是指向函数的指针。
- `bool (*pf)(const string &, const string &);` 注：两端的括号不可少。
- **函数指针形参**：
  - 形参中使用函数定义或者函数指针定义效果一样。
  - 使用类型别名或者`decltype`。
- **返回指向函数的指针**：1.类型别名；2.尾置返回类型。
