# 第三章 字符串、向量和数组

## using声明
- 使用某个命名空间，*如 `using std::cin`表示使用命名空间`std`中的名字`cin`*
- **头文件中不应该包含`using`声明**。这样使用了该头文件的源码也会使用这个声明，会带来风险  

## 标准库string  
- 标准库类型`string`表示可变长的字符序列  
- 包含头文件`#include <string>`  

### 定义和初始化string对象

初始化`string`对象的方式：

| 方式 | 解释 |
| -- | -- |
| `string s1` | 默认初始化，`s1`是个空字符串 |
| `string s2(s1)` | `s2`是`s1`的副本 |
| `string s2 = s1` | 等价于`s2(s1)`，`s2`是`s1`的副本 |
| `string s3("value")` | `s3`是字面值“value”的副本，除了字面值最后的那个空字符外 |
| `string s3 = "value"` | 等价于`s3("value")`，`s3`是字面值"value"的副本 |
| `string s4(n, 'c')` | 把`s4`初始化为由连续`n`个字符`c`组成的串 |

- 拷贝初始化（copy initialization）：使用等号`=`将一个已有的对象拷贝到正在创建的对象
- 直接初始化（direct initialization）：通过括号给对象赋值  

### string对象上的操作  

| 操作 | 解释 |
|-----|-----|
| `os << s` | 将`s`写到输出流`os`当中，返回`os` |
| `is >> s` | 从`is`中读取字符串赋给`s`，字符串以空白分割，返回`is` |
| `getline(is, s)` | 从`is`中读取一行赋给`s`，返回`is` |
| `s.empty()` | `s`为空返回`true`，否则返回`false` |
| `s.size()` | 返回`s`中字符的个数（无符号数） |
| `s[n]` | 返回`s`中第`n`个字符的引用，位置`n`从0计起 |
| `s1+s2` | 返回`s1`和`s2`连接后的结果 |
| `s1=s2` | 用`s2`的副本代替`s1`中原来的字符 |
| `s1==s2` | 如果`s1`和`s2`中所含的字符完全一样，则它们相等；`string`对象的相等性判断对字母的大小写敏感 |
| `s1!=s2` | 同上 |
| `<`, `<=`, `>`, `>=` | 利用字符在字典中的顺序进行比较，且对字母的大小写敏感 |  

- 通过`>>`读入：string对象会- 忽略掉开头的空白（包括空格、换行符和制表符），直到遇到下一处空白为止
- `getline()`：读取一整行，**包括空白符**，遇到换行符为止（换行符也被读入）。之后存入string对象（**不存换行符**）
  - 可以直接读入输入`getline(cin,s)//将输入一行一行读入s中`
- string比较大小：
  - 1.长度不同。较短的string小于较长的string  
  - 2.长度相同。两string第一对相异字符比较结果（字典顺序）  
- 当string对象和字符字面值或字符串字面值混在一起相加，**每个+的两侧至少有一个是string对象**  
```cpp
string s1 = "world";
string s2 = "hello" + ",";                  //错误：两个对象都不是string
string s3 = s1 + "," + "world";             //正确：等价于string s3 = (s1 + ",") + "world";    
```

### 处理string对象中的字符

- **ctype.h 与 cctype**：C++将c的标准库的名称去掉`.h`，前面加`c`

- `cctype`头文件中定义了一组标准函数：

| 函数 | 解释 |
|-----|-----|
| `isalnum(c)` | 当`c`是字母或数字时为真 |
| `isalpha(c)` | 当`c`是字母时为真 |
| `iscntrl(c)` | 当`c`是控制字符时为真 |
| `isdigit(c)` | 当`c`是数字时为真 |
| `isgraph(c)` | 当`c`不是空格但可以打印时为真 |
| `islower(c)` | 当`c`是小写字母时为真 |
| `isprint(c)` | 当`c`是可打印字符时为真 |
| `ispunct(c)` | 当`c`是标点符号时为真 |
| `isspace(c)` | 当`c`是空白时为真（空格、横向制表符、纵向制表符、回车符、换行符、进纸符） |
| `isupper(c)` | 当`c`是大写字母时为真 |
| `isxdigit(c)` | 当`c`是十六进制数字时为真 |
| `tolower(c)` | 当`c`是大写字母，输出对应的小写字母；否则原样输出`c` |
| `toupper(c)` | 当`c`是小写字母，输出对应的大写字母；否则原样输出`c` |

- 遍历字符串：使用**范围for**（range for）语句： `for (auto c: str)`，或者 `for (auto &c: str)`使用引用直接改变字符串中的字符
  - 使用auto更容易保证`c`的类型正确（这里c是`char`）
```cpp
string str("something");
for (auto c : str)                  //对于str中的每一个字符
  cout << c <<endl;                 //输出当前字符，后面紧跟一个换行符
```
- 通过下标运算符`[]`访问单个字符，`s[0]`为第一个字符，类型为`char`

## 标准库vector  
- vector是一个**容器**（包含其他对象），也是一个类模板
  - vector不包含引用
  - 类模板：本身不是类，但可以**实例化instantiation**出一个类。 `vector`是一个模板， `vector<int>`是一个类型
  - 通过将类型放在类模板名称后面的**尖括号**中来指定**类型**，*如`vector<int> ivec`*  
### 定义和初始化vector对象  
| 方法 | 解释 |
|-----|-----|
| `vector<T> v1` | `v1`是一个空`vector`，它潜在的元素是`T`类型的，执行默认初始化 |
| `vector<T> v2(v1)` | 将`v1`拷贝给`v2`，`v2`中包含有`v1`所有元素的副本 |
| `vector<T> v2 = v1` | 等价于`v2(v1)`，`v2`中包含`v1`所有元素的副本 |
| `vector<T> v3(n, val)` | `v3`包含了n个重复的元素，每个元素的值都是`val` |
| `vector<T> v4(n)` | `v4`包含了n个重复地执行了**值初始化**的对象 |
| `vector<T> v5{a, b, c...}` |**列表初始化**， `v5`包含了初始值个数的元素，每个元素被赋予相应的初始值 |
| `vector<T> v5={a, b, c...}` | 等价于`v5{a, b, c...}` |  
- 值初始化：内置类型为0，类类型由类默认初始化  
```cpp
vector<int> v1(10);                 //v1有10个元素，每个元素值都是0
vector<int> v2{10};                 //v2有1个元素，值为10

vector<int> v3(10,1);               //v3有10个元素，每个元素值都是1
vector<int> v4{10,1};               //v4有2个元素，值分别是10和1                    
```  
- 圆括号：提供的值用来构造vector对象
- 花括号：提供的值为初始化列表
  - 如果使用花括号但提供的值不能用来初始化列表，编译器会用其构造对象  *如：`vector<string> v5{10,"hi"}//v5有10个值为hi的元素`*
  
### 向vector对象中添加元素

- `v.push_back(e)` 在尾部增加元素  
- 如果循环体内部有向vector对象添加元素的语句，则不能使用范围for循环  

### 其他vector操作

| 操作 | 解释 |
|-----|-----|
| `v.emtpy()` | 如果`v`不含有任何元素，返回真；否则返回假 |
| `v.size()` |  返回`v`中元素的个数|
| `v.push_back(t)` | 向`v`的尾端添加一个值为`t`的元素 |
| `v[n]` | 返回`v`中第`n`个位置上元素的**引用** |
| `v1 = v2` | 用`v2`中的元素拷贝替换`v1`中的元素  |
| `v1 = {a,b,c...}` | 用列表中元素的拷贝替换`v1`中的元素 |
| `v1 == v2` | `v1`和`v2`相等当且仅当它们的元素数量相同且对应位置的元素值都相同 |
| `v1 != v2` | 同上 |
| `<`,`<=`,`>`, `>=` | 以字典顺序进行比较（规则同string） |

- `vector`对象（以及`string`对象）的下标运算符，只能对确知已存在的元素执行下标操作，不能用于添加元素
```cpp
vector<int> ivec;
cout << ivec[0];                      //错误：ivec不含有任何元素

vector<int> ivec2(10);
cout << ivec2[10];                    //错误：ivec2元素的合法索引是从0到9    
```

## 迭代器iterator

- 所有标准库容器都可以使用迭代器
- 类似于指针类型，迭代器也提供了对对象的间接访问

### 使用迭代器

- 迭代器定义：`vector<int>::iterator iter`
- `auto b = v.begin();`返回指向第一个元素的迭代器
- `auto e = v.end();`返回指向最后一个元素的下一位置（尾后,one past the end）的迭代器（off the end）
  - 不能对其递增`++`或解引用
- 如果容器为空， `begin()`和 `end()`返回的是同一个迭代器都是尾后迭代器
- 使用解引用符`*`访问迭代器指向的元素
- 养成使用迭代器和`!=`的习惯（所有标准库容器的迭代器都定义了==和!=，大多没有定义<）
- **容器**：可以包含其他对象；但所有的对象必须类型相同
- **迭代器（iterator）**：每种标准容器都有自己的迭代器。`C++`倾向于用迭代器而不是下标遍历元素
- **const_iterator**：只能读取容器内元素不能改变
  - 常量容器对象只能用常量迭代器
- **箭头运算符**： 如果对象是类，可以使用迭代器访问成员，`it->mem`等价于 `(*it).mem`
- **注**：但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素，会使迭代器失效

标准容器迭代器的运算符:

| 运算符 | 解释 |
|-----|-----|
| `*iter` | 返回迭代器`iter`所指向的**元素的引用** |
| `iter->mem` | 等价于`(*iter).mem` |
| `++iter` | 令`iter`指示容器中的下一个元素 |
| `--iter` | 令`iter`指示容器中的上一个元素 |
| `iter1 == iter2` | 判断两个迭代器是否相等（指向同一个元素或都是尾后迭代器） |

### 迭代器运算

`vector`和`string`迭代器支持的运算：

| 运算符 | 解释 |
|-----|-----|
| `iter + n` | 迭代器加上一个整数值仍得到一个迭代器，迭代器指示的新位置和原来相比向前移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置|
| `iter - n` | 迭代器减去一个证书仍得到一个迭代器，迭代器指示的新位置比原来向后移动了若干个元素。结果迭代器或者指向容器内的一个元素，或者指示容器尾元素的下一位置 |
| `iter1 += n` | 迭代器加法的复合赋值语句，将`iter1`加n的结果赋给`iter1` |
| `iter1 -= n` | 迭代器减法的复合赋值语句，将`iter2`减n的加过赋给`iter1` |
| `iter1 - iter2` | 返回`difference_type`类型。两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后得到左侧的迭代器。参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一位置 |
| `>`、`>=`、`<`、`<=` | 迭代器的关系运算符，如果某迭代器指向的容器位置在另一个迭代器所指位置之前，则说明前者小于后者。参与运算的两个迭代器必须指向的是同一个容器中的元素或尾元素的下一位置 |

- **difference_type**：带符号整型。保证足够大以存储任何两个迭代器对象间的距离，可正可负

## 数组

- 相当于vector的低级版，**长度固定**。

### 定义和初始化内置数组

- 初始化：`char input_buffer[buffer_size];`，长度必须是const表达式，或者不写，让编译器自己推断
- 数组不允许直接赋值给另一个数组（数组=数组）
- 数组元素是对象，不存在引用的数组
- 字符串字面值`" "`初始化`char`数组时，结尾自动生成空字符；字符字面值`' '`不会
```cpp
int *parr[42];                //含有42个整型指针的数组
int (*Parray)[10] = &arr;     //Parray指向一个含有10个整型的数组
int (&arrRef)[10] = arr;      //arrRef引用一个含有10个整型的数组
int *(&arry)[10] = ptrs;      //arry是数组ptrs的引用，该数组含有10个整型指针
```
### 访问数组元素

- 数组下标的类型：`size_t` ，无符号数
  = 大于等于0，小于数组大小
- 可使用for范围遍历

### 数组和指针

- 使用数组时，编译器一般会把它转换成指针
  - 在表达式中使用数组名时，名字会自动转换成指向数组的第一个元素的指针
  - `auto`推断数组为**指针类型**
  - `decltype`推断数组为**数组类型**
- 指向数组的指针也是**迭代器**，可以执行所有迭代器运算
  - `begin`和`end`作为函数，将数组作为他们的参数
  ```cpp
  int ia[] = {0,1,2,3,4,5,6,7,8,9};               //ia是含有10个元素的整型数组
  int *p = ia;                                    //p指向ia的第一个元素
  int *beg = begin(ia);                           //beg等同于p，指向ia的第一个元素
  int *last = end(ia);                            //last指向ia尾元素的下一位置
  ```
- 标准库类型限定使用的下标必须是无符号类型，而内置的下标**可以处理负值**
```cpp
int *p = &ia[2];                                   
int j = p[1];                                      //p[1]等价于*(p + 1),表示ia[3]
int k = p[-2];                                     //p[-2]等价于*(p - 2)，表示ia[0]
```
