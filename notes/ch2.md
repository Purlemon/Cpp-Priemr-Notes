# 第二章 变量和基本类型

## 基本内置类型  
        
### 算术类型
| 类型 | 含义 | 最小尺寸|
|---|---|---|
| `bool` | 布尔类型  | 8bits |
| `char`| 字符 | 8bits |
| `wchar_t` | 宽字符 | 16bits |
| `char16_t` | Unicode字符 | 16bits |
| `char32_t` | Unicode字符 | 32bits |
| `short` | 短整型 | 16bits |
| `int` | 整型 | 16bits  |
| `long` | 长整型 | 32bits |
| `long long` | 长整型 | 64bits  |
| `float` | 单精度浮点数 | 6位有效数字 |
| `double` | 双精度浮点数 | 10位有效数字 |
| `long double` | 扩展精度浮点数 | 10位有效数字 |
- 可寻址的最小内存块称为“字节（byte）”，储存的基本单元称为“字（word）”  
  - 1 byte=8 bit  
  - 1 word= 32 bit

### 带符号类型和无符号类型  
- `int`、`short`、`long`、`long long`都是带符号的，在这些类型名称前添加`unsigned`就可以得到无符号类型
- **`unsigned int`可以缩写成`unsigned`**  
- `char`会表现为`signed char`或`unsigned char`，由编译器决定

### 如何选择类型
- 1.当明确知晓数值不可能是负数时，选用无符号类型
- 2.使用`int`执行整数运算。一般`long`的大小和`int`一样，而`short`常常显得太小。除非超过了`int`的范围，选择`long long`
- 3.算术表达式中不要使用`char`或`bool`。如果使用`char`应明确指定它的类型是`sigened char`或者`unsigned char`  
- 4.浮点运算选用`double`  

### 类型转换
- 非布尔型赋给布尔型，初始值为0则结果为false，否则为true。  
```cpp
int i=42;
if(i)           //if的值将为true  
  i=0；
```
- 布尔型赋给非布尔型，初始值为false结果为0，初始值为true结果为1。
- 超出范围的值赋给无符号类型，结果是初始值对无符号类型表示数值总数取模后的余数  
  （如果是负数，[会直接使用负数的补码表示结果](https://blog.csdn.net/Songbai_Pu/article/details/9172689)，*如：将-1赋给8 bit的`unsigned char`结果是255*）  
 - 超出范围的值赋给带符号数，结果是**未定义的（undefined）**  
 - **当算术表达式中既含有`int`又含有无符号数时,`int`值将会转换为无符号数**  
 ```cpp
 int i=1;
 unsigned j=-1;
 cout << i*j ;          //输出4294967295
 ```  
 
 ### 字面值常量
 字面值常量（literal constant），“字面值”是指只能用它的值称呼它，“常量”是指其值不能修改。每个字面值都有相应的类型，3.14是`double`型，2是`int`型。只有内置类型存在字面值  
 - **1.整型字面值**  
 用十进制（*如：24*）、八进制（以0开头，*如：024*）、十六进制（以0x开头，*如：0x24*）表示  
   - 十进制字面值是带符号数，在能容纳的情况下取`int`、`long`、`long long`中最小  
     - 形如-42的十进制字面值，那个负号并不在字面值之内，它的作用仅仅对字面值取负而已
   - 八进制和十六进制字面值是带符号数或无符号数，在能容纳的情况下取`int`、`unsigned int`、`long`、`unsigned long`、`long long`、`unsigned long long`中最小  
   - 在整型后加**后缀**可指定类型 
     - u或U：`unsigned int`、`unsigned long`、`unsigned long long`中最小  
     - l或L：`long`、`unsigned long`、`long long`、`unsigned long long`中最小  
     - ll或LL：`long long`、`unsigned long long`中最小  
     - U可以和L混用，如UL或LU：`unsigned long`、`unsigned long long`中最小  
- **2.浮点数字面值**  
用十进制或科学计数法（指数用E或e）表示，默认为`double`，*如：3.14、3.14e1*
  - 在浮点数后加**后缀**可指定类型  
    - f或F：`float`
    - l或L；`long double`  
- **3.字符和字符串字面值**  
  - 由单引号括起来的一个字符称为char型字面值，*如：'a'*
  - 由双引号括起来的零个或多个字符称为字符串字面值，*如："Hello"*
    - 字符串字面值实际长度比内容多1，编译器自动在结尾处添加空字符（'\0'）
  - 在字符前加**前缀**可指定类型，*如：L‘a’、u8"hi!"*  
    - u：char16_t  
    - U：char32_t  
    - L：wchar_t  
    - u8：char（UTF-8,用8 bit编写一个Unicode字符，仅用于字符串字面常量）
- **4.布尔字面值**  
  true和false  
- **5.转义序列**  
  - 非打印字符和特殊字符（如单引号、双引号、反斜杠）都要写为转义字符（以反斜杠开头），下列转义序列被当作一个字符使用  
  - 也可以使用泛化的转义序列
    - \后加3个以内八进制数，若超过3个，只有前3个数字与\构成转义序列，*如：\12*  
    - \x后加多个十六进制数，*如：\x1234*
    
 | 字符| 转义序列 | 字符| 转义序列 |字符| 转义序列 |
 | --- | ---  | --- | ---  |--- | ---  |
 | 换行符 | \n | 纵向制表符 | \v |  横向制表符 | \t  | 回车符 | \r | 
 | 反斜线 | \\\  | 退格符 | \b |  问号 | \\? |  进纸符 | \f |  响铃符 | \a | 
 | 单引号 | \\'  | 双引号 | \\" |  

## 变量  
**变量**提供一个**具名**的、可供程序操作的存储空间。   `C++`中**变量**和**对象**一般可以互换使用。

### 变量定义（define）  
- **定义形式**：基本数据类型（base type） + 一个或多个声明符（declarator）列表（变量名也是声明符）  
*如`int sum = 0, value, units_sold = 0;`*  
- **初始化**（initialized）：以下4条语句都可以做到这一点
```cpp
int x = 0;  
int x(0);  
int x = {0};             //列表初始化            
int x{0};                //列表初始化  
```  
- **初始化不是赋值**  
  - 初始化 = 创建变量 + 赋予初始值
  - 赋值 = 擦除对象的当前值 + 用新值代替 
- 如果使用**列表初始化**且初始值存在丢失信息的风险，编译器会报错  
```cpp  
long double id = 3.1415926536;  
int a{id}, b={id};              //报错：转换未执行，有丢失信息风险  
int c(id), d=id;                //正确  
```  
- **默认初始化**：内置类型的变量为被显示初始化，将被默认初始化（default initialized）  
  - 定义在任何函数体之**外**的内置变量：被初始化为0  
  - 定义在任何函数体之**内**的内置变量：不被初始化（uninitialized），如果试图拷贝或以其它形式访问此类值会引发错误  
 
### 变量声明（declaration）和定义的关系  
为了支持分离式编译，C++将声明和定义区分开。**声明**使得名字为程序所知。**定义**负责创建与名字关联的实体  
- 只声明不定义：在变量前添加`extern`关键字。  
但如果包含了初始值，就变成了定义
- 变量只能被定义一次，但是可以多次声明  
  - 在函数体内部，初始化一个由`extern`关键字标记的变量，将引发错误  
  - 变量的定义只能出现在一个文件中，其他用到该变量的文件必须对其进行声明，却绝不能重复定义
```cpp
extern int pi;                  //声明pi
extern double pi = 3.14;        //声明并定义pi，将pi初始化为3.14
int pi;                         //声明并定义pi  
int pi = 3.14;                  //声明并定义pi，将pi初始化为3.14  
```

### 标识符（identifier）  
- 由字母、数字、下划线组成。长度没有限制，对大小写敏感  
- 为了给C++标准库预留一些名字，尽量遵守以下规则： 
  - 不能连续出现两个下划线  
  - 不能以下划线紧连着大写字母开头  
  - 定义在函数体外的，不能以下划线开头  
  
### 名字的作用域  
- 作用域（scope）以花括号分隔  
  - 同一个名字在不同作用域指向不同的实体  
  - 名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束  
 ```cpp
int sum = 0;
for (int i = 0; i < 10; i++)
    sum++;
cout << i;              //错误，无法在for语句外访问i  
 ```  
-  **如果函数有可能用到某全局变量，则不宜再定义一个同名的局部变量**

 ## 复合类型
 
 ### 引用  
  引用（reference）并非对象，它只是为一个已存在的对象所起的另外一个名字  
  - 引用必须被初始化  
  - 一旦初始化完成，引用将和它的初始化对象一直绑定（bind）再一起，无法更改  
    - **因此引用初始化不是拷贝**
  - 不能定义引用的引用
  - 引用类型与之绑定的对象类型严格匹配
  - 引用只能绑定在对象上，不能与字面值或计算结果绑定  
  ```cpp
  int ival = 1024;
  int &refVal = ival;           //refVal初始化（是ival的另一个名字）
  int &refVal;                  //错误，引用必须被初始化
  double dval = 3.14;
  int &refVal1 = dval;          //错误，此处引用类型的初始值必须是int型对象
  //允许在一条语句中定义多个引用
  int i = 1024, i2 = 2048;
  int &r = i, r2 = i2;
  int i3 = 4096, &r3 = i3;
  ```  
  
  ### 指针  
  指针（pointer）是“指向（point to）”另外一种类型的复合类型。本身是一个对象，允许对指针赋值和拷贝。无需在定义时赋初值  
 - 指针存放某个对象的**地址**，获取地址时需要使用**取地址符&**  
   - 引用不是对象，不能定义指向引用的指针  
   - 指针类型必须和它指向的对象**严格匹配**  
 ```cpp
 double dval;           //正确：初始值是double型对象的地址
 double *pd = &dval;    //正确：初始值是指向double对象的指针
 
 int *pi = pd;          //错误：指针pi和pd的类型不匹配
 pi = &dval;            //错误：试图把double型对象地址赋给int型变量
 ```
 - **指针值**四种状态：  
   -1.指向一个对象  
   -2.指向紧邻对象的下一个位置  
   -3.空指针。指针没有指向任何对象  
   -4.无效指针。上述以外的其他值  
  - 指针访问对象，使用**解引用符***
    - 给解引用的对象赋值就是给指针所指的对象赋值  
  ```cpp
  int ival = 42;
  int *p = &ival;               //p是指向ival的指针
  cout << *p;                   //输出42
  *p = 0;
  cout << *p;                   //输出0
  ```
  - **空指针**
  ```cpp
  int *p = nullptr;
  int *p = 0;                   //0是字面值常量，不能用值为0的int变量赋给指针
  int *p = NULL;                //老旧的做法，需要#include cstdlib，不推荐
  ```
  - **指针相等**（==为true）：类型相同，存放的地址值相同  
  - 分辨赋值语句到底是改变了指针的值还是指针所指向对象的值：  
  **记住赋值永远改变的是等号左侧的对象**  
  - void* 指针：存放任意对象的地址。以void* 的视角内存仅仅是内存空间，不知道数据是什么类型
    - 和其他指针比较。仅仅可以做的事：  
    - 作为函数的输入或输出  
    - 赋值给另一个void* 指针
  
  - **指向指针的指针**  
    - 通过\*的数量区分。\*\*表示指向指针的指针，\*\*\*表示指向指针的指针的指针
    - 访问初始对象，需要对指向指针的指针进行两次解引用  
    ```cpp
    int ival = 1024;  
    int *pi = &ival;            //pi是指向int型的指针
    int **ppi = &pi;            //ppi是指向int型指针pi的指针
    //输出ival  
    cout << ival 
         << *pi  
         << **ppi; 
    ```  
   - **指向指针的引用**  
     - 理解复杂声明语句时，从右向左读。离变量名最近的符号对变量有最直接的影响  
     ```cpp 
     int i = 42;
     int *p = &i;               //p是一个int型指针
     int *&r = p;               //r是对指针p的引用  
     ```  
     
 ## const限定符
 
 `const`定义一个常量，它的值不能被改变  
 ### const初始化  
 - const对象**必须初始化**  
 - const变量默认不能被其他文件访问
   - 解决办法：无论是定义还是声明，都在const前添加extern（**只需定义一次**）
### const引用  
**常量只能用常量引用绑定**  
```cpp  
const int ival = 42;
int &r1 = ival;                 //错误：不能用普通引用绑定常量对象
const int &r2 = ival;           //正确
```
- **初始化**
  - 引用的类型必须和引用对象一致
  - 允许绑定非常量对象、字面值、表达式（只要结果能转换成引用的类型）  
    - 编译器会为表达式的结果临时创建一个**临时量**（temporary）对象。如果常量引用右端是表达式，则它会绑定这个临时量对象  
    - 这种行为无意义，是非法行为
  ```cpp
  int i = 42;
  const int &r1 = i;            //正确
  const int &r2 = 42;           //正确
  const int &r3 = r1 * 2;       //正确
  int &r4 = r1 * 2;             //错误：r4是个普通的引用
  ```  
- 常量引用绑定的非常量对象无法被直接修改，但可以通过其他手段**间接修改**
```cpp
int ival = 1024;
const int &r1 = ival;
int &r2 = ival;
r1 = 0;                         //错误：r1是一个常量引用
r2 = 0;                         //正确：r2并非常量引用
ival = 0;                       //正确：ival并非常量
```  
### const和指针  
**const在类型前：不能通过该指针改变所指对象的值**   
**const在类型后：不能改变该指针指向的地址**
- `const int *p1`:**p1是指向常量的指针**   
  - 常量对象只能使用*指向常量的指针* 
  - 不可以通过*指向常量的指针*更改其指向对象的值  
  - *指向常量的指针*可以指向非常量，允许通过其他方式**间接修改**指向的非常量  
- `int *const p2`:**p2是常量指针**，指针本身是常量  
  - *常量指针*可以指向任意非常量对象  
  - *常量指针*一旦初始化，它的指向的地址无法被改变  
  - 可以通过*常量指针*更改其指向对象的值  
```cpp
const int ival = 42;
const int *p1 = &ival;                  //正确：常量可以使用指向常量的指针p1  
int *const p2 = &ival;                  //错误：p2是常量指针，不是指向常量对象的指针  
const int *const p3 = &ival;            //正确：p3是指向常量对象的常量指针  
```

 




